#!/usr/bin/env python3
"""
Weekly Business Summary Generator

Generates a comprehensive weekly business summary email including:
1. Strategic priorities for the week (AI-generated from client contexts)
2. Upcoming tasks and deliverables
3. Client performance data from last week
4. Meeting notes imported from Granola
5. New knowledge base documents

NOTE: Industry news and AI newsletters are sent in a SEPARATE email
      via weekly-news-digest.py

Runs every Monday at 8:30 AM
"""

import os
import sys
import base64
import anthropic
from pathlib import Path
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Gmail API imports
try:
    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build
except ImportError:
    print("Error: Gmail API dependencies not installed.")
    sys.exit(1)

# Configuration
PROJECT_ROOT = Path("/Users/administrator/Documents/PetesBrain")
KB_ROOT = PROJECT_ROOT / "roksys/knowledge-base"
AI_NEWS_OLD = PROJECT_ROOT / "roksys/news/emails"  # Old location
AI_NEWS_NEW = KB_ROOT / "_inbox/emails"  # New location (will be processed into KB)

SCOPES = ['https://www.googleapis.com/auth/gmail.send', 'https://www.googleapis.com/auth/gmail.readonly']


def log_message(message):
    """Print and log message"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")


def authenticate():
    """Authenticate with Gmail API."""
    creds = None
    # Use separate token file for weekly summary to avoid scope conflicts
    token_file = PROJECT_ROOT / 'shared/email-sync/token-weekly-summary.json'
    credentials_file = PROJECT_ROOT / 'shared/email-sync/credentials.json'

    if token_file.exists():
        creds = Credentials.from_authorized_user_file(str(token_file), SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            if not credentials_file.exists():
                print(f"Error: credentials.json not found at {credentials_file}")
                return None

            flow = InstalledAppFlow.from_client_secrets_file(
                str(credentials_file), SCOPES)
            creds = flow.run_local_server(port=0)

        with open(token_file, 'w') as token:
            token.write(creds.to_json())

    return creds


def get_files_from_last_week(directory, days=7):
    """Get files modified in the last N days"""
    if not directory.exists():
        return []

    cutoff_date = datetime.now() - timedelta(days=days)
    recent_files = []

    for file_path in directory.rglob("*.md"):
        if file_path.stat().st_mtime > cutoff_date.timestamp():
            recent_files.append(file_path)

    return sorted(recent_files, key=lambda x: x.stat().st_mtime, reverse=True)


def read_markdown_file(file_path):
    """Read markdown file and extract metadata + content"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Extract title from frontmatter or filename
        title = file_path.stem.replace('_', ' ').replace('-', ' ').title()

        if '---' in content:
            # Has frontmatter
            parts = content.split('---', 2)
            if len(parts) >= 3:
                frontmatter = parts[1]
                body = parts[2]

                # Try to extract title from frontmatter
                for line in frontmatter.split('\n'):
                    if line.startswith('title:'):
                        title = line.replace('title:', '').strip()
                        break

                return {'title': title, 'content': body, 'frontmatter': frontmatter}

        return {'title': title, 'content': content, 'frontmatter': ''}
    except Exception as e:
        log_message(f"Error reading {file_path}: {e}")
        return None


def get_client_performance():
    """Read client performance data from JSON file generated by fetch-weekly-client-performance.py"""
    try:
        import json

        performance_file = PROJECT_ROOT / "data/cache/weekly-client-performance.json"

        if not performance_file.exists():
            log_message(f"  Performance data file not found: {performance_file}")
            log_message("  Tip: Run fetch-weekly-client-performance.py to generate this data")
            return None

        with open(performance_file, 'r') as f:
            data = json.load(f)

        log_message(f"  Loaded performance data for {len(data.get('clients', []))} clients")
        return data

    except Exception as e:
        log_message(f"Warning: Could not read client performance: {e}")
        return None


def get_upcoming_tasks():
    """Get tasks for the week ahead from Google Tasks via MCP server token"""
    try:
        from googleapiclient.discovery import build

        # Use MCP Google Tasks server token (already has tasks scope)
        mcp_tasks_dir = Path(__file__).parent.parent / 'mcp-servers/google-tasks-mcp-server'
        token_file = mcp_tasks_dir / 'token.json'

        if not token_file.exists():
            log_message(f"  MCP Tasks token not found at {token_file}")
            return []

        # Load credentials with tasks scope (use full scope, not readonly)
        tasks_scopes = ['https://www.googleapis.com/auth/tasks']
        creds = Credentials.from_authorized_user_file(str(token_file), tasks_scopes)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
                # Save refreshed token
                with open(token_file, 'w') as token:
                    token.write(creds.to_json())
            else:
                log_message("  Tasks credentials expired and cannot refresh")
                return []

        service = build('tasks', 'v1', credentials=creds)

        # Get all task lists
        task_lists = service.tasklists().list().execute()

        upcoming_tasks = []
        today = datetime.now()
        week_ahead = today + timedelta(days=7)

        for task_list in task_lists.get('items', []):
            list_name = task_list['title']

            # Get tasks from this list
            tasks = service.tasks().list(
                tasklist=task_list['id'],
                showCompleted=False,
                showHidden=False
            ).execute()

            for task in tasks.get('items', []):
                title = task.get('title', '')
                notes = task.get('notes', '')
                due = task.get('due')

                # Parse client from task list name if available
                client = None
                if '[' in list_name and ']' in list_name:
                    client = list_name.split('[')[1].split(']')[0]

                task_info = {
                    'title': title,
                    'notes': notes,
                    'due': due,
                    'list': list_name,
                    'client': client
                }

                # Include tasks with due dates in the next week, or important tasks without due dates
                if due:
                    try:
                        due_dt = datetime.fromisoformat(due.replace('Z', '+00:00'))
                        if today <= due_dt.replace(tzinfo=None) <= week_ahead:
                            upcoming_tasks.append(task_info)
                    except:
                        pass
                elif len(notes) > 50:  # Tasks with substantial notes are likely important
                    upcoming_tasks.append(task_info)

        return upcoming_tasks

    except Exception as e:
        log_message(f"Warning: Could not fetch upcoming tasks: {e}")
        return []


def get_weekly_client_strategy():
    """Get AI-generated weekly strategic priorities for all clients"""
    strategy_file = PROJECT_ROOT / 'shared' / 'data' / 'weekly-client-strategy.json'

    if not strategy_file.exists():
        return None

    try:
        import json
        with open(strategy_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        log_message(f"Warning: Could not read client strategy: {e}")
        return None

def get_granola_meeting_imports():
    """Get Granola meeting imports from the last 7 days"""
    try:
        import json
        history_file = PROJECT_ROOT / 'tools/granola-importer/.import_history.json'

        if not history_file.exists():
            return None

        with open(history_file, 'r') as f:
            history = json.load(f)

        # Get imports from last 7 days
        cutoff = datetime.now() - timedelta(days=7)
        recent_imports = []

        for doc_id, import_data in history.get('imported', {}).items():
            imported_at = import_data.get('imported_at', '')
            try:
                import_time = datetime.fromisoformat(imported_at)
                if import_time >= cutoff:
                    # Extract filename and client
                    file_path = import_data.get('file_path', '')
                    filename = Path(file_path).name if file_path else 'Unknown'
                    client = import_data.get('client', '_unassigned')

                    recent_imports.append({
                        'filename': filename,
                        'client': client,
                        'imported_at': imported_at,
                        'time_display': import_time.strftime('%b %d, %H:%M')
                    })
            except ValueError:
                continue

        # Sort by import time (newest first)
        recent_imports.sort(key=lambda x: x['imported_at'], reverse=True)

        # Group by client
        grouped = {}
        for imp in recent_imports:
            client = imp['client']
            if client == '_unassigned':
                client = '‚ö†Ô∏è Unassigned'
            else:
                client = client.replace('-', ' ').title()

            if client not in grouped:
                grouped[client] = []
            grouped[client].append(imp)

        return {
            'total': len(recent_imports),
            'grouped': grouped,
            'has_unassigned': any(imp['client'] == '_unassigned' for imp in recent_imports)
        }

    except Exception as e:
        log_message(f"Warning: Could not read Granola imports: {e}")
        return None


def get_launchagent_status():
    """Check status of PetesBrain LaunchAgents"""
    try:
        import subprocess

        # Get list of all loaded LaunchAgents
        result = subprocess.run(
            ['launchctl', 'list'],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode != 0:
            return {'error': 'Failed to query launchctl'}

        # Parse output and find petesbrain agents
        agents = []
        failed_agents = []

        for line in result.stdout.split('\n'):
            if 'petesbrain' in line.lower():
                parts = line.split()
                if len(parts) >= 3:
                    pid = parts[0]
                    exit_code = parts[1]
                    label = parts[2]

                    agent_info = {
                        'label': label,
                        'pid': pid,
                        'exit_code': exit_code,
                        'running': pid != '-',
                        'failed': exit_code != '0' and exit_code != '-'
                    }

                    agents.append(agent_info)

                    if agent_info['failed']:
                        failed_agents.append(agent_info)

        # Check for common issues
        issues = []

        # Check disk space
        try:
            disk_result = subprocess.run(
                ['df', '-h', str(PROJECT_ROOT)],
                capture_output=True,
                text=True,
                timeout=5
            )
            if disk_result.returncode == 0:
                lines = disk_result.stdout.split('\n')
                if len(lines) > 1:
                    parts = lines[1].split()
                    if len(parts) >= 5:
                        use_pct = parts[4].replace('%', '')
                        if int(use_pct) > 90:
                            issues.append(f"Disk space low: {use_pct}% used")
        except:
            pass

        return {
            'total_agents': len(agents),
            'failed_agents': failed_agents,
            'failed_count': len(failed_agents),
            'issues': issues,
            'healthy': len(failed_agents) == 0 and len(issues) == 0
        }

    except Exception as e:
        log_message(f"Warning: Could not check LaunchAgent status: {e}")
        return {'error': str(e)}

def get_resource_allocation_summary():
    """Analyze revenue vs time allocation from latest analysis file"""
    try:
        analysis_file = PROJECT_ROOT / 'roksys' / 'analysis-revenue-vs-time-allocation-2025-11-12.md'

        if not analysis_file.exists():
            return None

        # Parse the markdown file to extract key findings
        with open(analysis_file, 'r') as f:
            content = f.read()

        # Extract critical imbalances section
        summary = {
            'over_allocated': [],
            'under_allocated': [],
            'no_tasks': []
        }

        # Parse the comparative analysis table
        in_comparison = False
        for line in content.split('\n'):
            if '**ACTIVE CLIENTS**' in line:
                in_comparison = True
                continue

            if in_comparison and line.startswith('|') and '**' in line:
                parts = [p.strip() for p in line.split('|')]
                if len(parts) >= 5 and parts[1].startswith('**'):
                    client = parts[1].replace('**', '').strip()
                    revenue_pct = parts[2].strip()
                    time_pct = parts[3].strip()
                    variance = parts[4].strip()

                    # Parse variance
                    try:
                        variance_val = float(variance.replace('%', '').replace('+', '').replace('*', ''))
                    except:
                        continue

                    # Categorize
                    if time_pct == '0%':
                        summary['no_tasks'].append({
                            'client': client,
                            'revenue_pct': revenue_pct,
                            'variance': variance
                        })
                    elif variance_val > 5.0:  # Over-allocated by >5%
                        summary['over_allocated'].append({
                            'client': client,
                            'revenue_pct': revenue_pct,
                            'time_pct': time_pct,
                            'variance': variance
                        })
                    elif variance_val < -5.0:  # Under-allocated by >5%
                        summary['under_allocated'].append({
                            'client': client,
                            'revenue_pct': revenue_pct,
                            'time_pct': time_pct,
                            'variance': variance
                        })

            if in_comparison and line.startswith('---'):
                break

        # Only return if we have issues to report
        if summary['over_allocated'] or summary['under_allocated'] or summary['no_tasks']:
            return summary

        return None

    except Exception as e:
        log_message(f"Warning: Could not load resource allocation analysis: {e}")
        return None

def analyze_knowledge_base_with_claude(ai_emails, kb_documents, upcoming_tasks, performance_data=None, strategy_data=None, meeting_imports=None, launchagent_status=None, resource_allocation=None):
    """Use Claude API to analyze and summarize the knowledge base"""

    api_key = os.environ.get('ANTHROPIC_API_KEY')
    if not api_key:
        log_message("ERROR: ANTHROPIC_API_KEY not set")
        return None

    anthropic_client = anthropic.Anthropic(api_key=api_key)

    # Prepare content for Claude
    email_summaries = []
    for email in ai_emails[:20]:  # Limit to 20 most recent emails
        doc = read_markdown_file(email)
        if doc:
            email_summaries.append(f"### {doc['title']}\n{doc['content'][:1000]}")  # First 1000 chars

    kb_summaries = []
    for kb_doc in kb_documents[:10]:  # Limit to 10 most recent KB docs
        doc = read_markdown_file(kb_doc)
        if doc:
            kb_summaries.append(f"### {doc['title']}\n{doc['content'][:1000]}")

    # Prepare upcoming tasks summaries
    task_summaries = []
    for task in upcoming_tasks[:20]:  # Limit to 20 tasks
        client_prefix = f"[{task['client']}] " if task['client'] else ""
        due_str = f" (Due: {task['due'][:10]})" if task['due'] else ""
        task_summaries.append(f"{client_prefix}{task['title']}{due_str}")

    # Prepare weekly strategic priorities summaries
    strategy_summaries = []
    strategy_by_type = {}
    weekend_context = ""
    if strategy_data and strategy_data.get('priorities'):
        for priority in strategy_data['priorities']:
            client = priority.get('client', 'Unknown')
            type_key = priority.get('type', 'other')
            impact = priority.get('impact', 'medium')
            priority_text = priority.get('priority', '')
            why = priority.get('why', '')

            # Group by type for summary
            if type_key not in strategy_by_type:
                strategy_by_type[type_key] = []
            strategy_by_type[type_key].append(f"[{client}] {priority_text}")

            # Individual priority summary
            impact_emoji = "üî¥" if impact == "high" else ("üü°" if impact == "medium" else "‚ö™")
            strategy_summaries.append(f"{impact_emoji} [{client}] {priority_text} - {why}")

    # Extract weekend plans if available
    if strategy_data and strategy_data.get('weekend_plans'):
        plans = strategy_data['weekend_plans']
        weekend_context = f"""
**‚ö†Ô∏è WEEKEND PLANS DETECTED**: {plans.get('summary', 'Weekend plans')}
**Recommendation**: Aim to finish by lunchtime Friday ({plans.get('friday_date', 'Friday')}) to allow for travel/preparation.
"""

    # Prepare client performance summaries
    performance_summaries = []
    period_str = "data pending"
    if performance_data and performance_data.get('clients'):
        period = performance_data.get('period', {})
        current_week = period.get('current_week', {})
        period_str = f"{current_week.get('start', '')} to {current_week.get('end', '')}"

        for client_data in performance_data['clients'][:12]:  # All 12 clients
            name = client_data['name']
            curr = client_data['current_week']
            changes = client_data['changes']
            summary = client_data['summary']

            # Format performance line
            perf_line = f"{name}: ¬£{int(curr['revenue']):,} revenue, {int(curr['roas'])}% ROAS"
            if changes['trend'] == 'up':
                perf_line += f" (‚Üë {abs(int(changes['revenue_pct']))}% WoW)"
            elif changes['trend'] == 'down':
                perf_line += f" (‚Üì {abs(int(changes['revenue_pct']))}% WoW)"
            else:
                perf_line += f" (‚Üí stable)"

            # Add outliers if present
            if client_data.get('outliers'):
                outlier_dates = [o['date'] for o in client_data['outliers'][:2]]
                perf_line += f" | Notable: {', '.join(outlier_dates)}"

            performance_summaries.append(perf_line)

    # Prepare meeting imports summaries
    meeting_summaries = []
    if meeting_imports and meeting_imports.get('total', 0) > 0:
        for client, meetings in sorted(meeting_imports['grouped'].items()):
            meeting_summaries.append(f"{client}: {len(meetings)} meeting(s)")
            for meeting in meetings[:3]:  # Show up to 3 per client
                meeting_summaries.append(f"  ‚Ä¢ {meeting['filename']} ({meeting['time_display']})")

    # Prepare LaunchAgent status summaries
    agent_summaries = []
    if launchagent_status:
        if 'error' in launchagent_status:
            agent_summaries.append(f"‚ö†Ô∏è Could not check agent status: {launchagent_status['error']}")
        else:
            total = launchagent_status.get('total_agents', 0)
            failed = launchagent_status.get('failed_count', 0)
            healthy = launchagent_status.get('healthy', True)

            if healthy:
                agent_summaries.append(f"‚úÖ All {total} LaunchAgents healthy")
            else:
                agent_summaries.append(f"‚ö†Ô∏è {failed}/{total} LaunchAgents failed:")
                for agent in launchagent_status.get('failed_agents', []):
                    agent_summaries.append(f"  - {agent['label']}: exit code {agent['exit_code']}")

            for issue in launchagent_status.get('issues', []):
                agent_summaries.append(f"‚ö†Ô∏è {issue}")

    # Prepare resource allocation summaries
    allocation_summaries = []
    if resource_allocation:
        # Clients with no tasks
        if resource_allocation.get('no_tasks'):
            allocation_summaries.append("**‚ö†Ô∏è CLIENTS WITH NO ACTIVE TASKS:**")
            for item in resource_allocation['no_tasks']:
                allocation_summaries.append(f"  - {item['client']}: {item['revenue_pct']} of revenue, 0% time allocation")

        # Over-allocated clients
        if resource_allocation.get('over_allocated'):
            allocation_summaries.append("**üî¥ OVER-ALLOCATED CLIENTS** (receiving disproportionate time):")
            for item in resource_allocation['over_allocated']:
                allocation_summaries.append(f"  - {item['client']}: {item['revenue_pct']} revenue, {item['time_pct']} time ({item['variance']} variance)")

        # Under-allocated clients
        if resource_allocation.get('under_allocated'):
            allocation_summaries.append("**üî¥ UNDER-ALLOCATED CLIENTS** (not receiving enough time):")
            for item in resource_allocation['under_allocated']:
                allocation_summaries.append(f"  - {item['client']}: {item['revenue_pct']} revenue, {item['time_pct']} time ({item['variance']} variance)")

    prompt = f"""You are analyzing the Pete's Brain knowledge base for a weekly business summary email focused on THE WEEK AHEAD.

{weekend_context}
**WEEKLY STRATEGIC PRIORITIES** ({len(strategy_summaries)} priorities across {strategy_data.get('clients_with_priorities', 0) if strategy_data else 0} clients):
{chr(10).join(strategy_summaries[:30]) if strategy_summaries else 'Strategic priorities pending - run weekly-client-strategy-generator.py'}

**BY STRATEGY TYPE**:
{chr(10).join([f"  {type_name}: {len(items)}" for type_name, items in strategy_by_type.items()]) if strategy_by_type else 'N/A'}

**CLIENT PERFORMANCE - LAST WEEK** ({len(performance_summaries)} clients, {period_str if performance_summaries else 'data pending'}):
{chr(10).join(performance_summaries) if performance_summaries else 'Performance data pending - run fetch-weekly-client-performance.py'}

**UPCOMING TASKS - WEEK AHEAD** ({len(upcoming_tasks)} tasks):
{chr(10).join(task_summaries) if task_summaries else 'No upcoming tasks'}

**MEETING NOTES IMPORTED THIS WEEK** ({meeting_imports.get('total', 0) if meeting_imports else 0} meetings from Granola):
{chr(10).join(meeting_summaries) if meeting_summaries else 'No meetings imported this week'}

**NEW KNOWLEDGE BASE DOCUMENTS THIS WEEK** ({len(kb_documents)} total):
{chr(10).join(kb_summaries) if kb_summaries else 'No documents this week'}

**LAUNCHAGENT STATUS** (PetesBrain automation health):
{chr(10).join(agent_summaries) if agent_summaries else 'Agent status not available'}

**RESOURCE ALLOCATION** (Client time vs revenue balance):
{chr(10).join(allocation_summaries) if allocation_summaries else '‚úÖ All clients have proportional time allocation'}

Please create a CONCISE, FORWARD-LOOKING weekly summary (aim for ~2-3 pages max) with these sections:

0. **‚ö†Ô∏è WEEKEND PLANS NOTICE** (if weekend plans detected)
   - ONLY if weekend plans exist in strategy data
   - Prominent warning box at top
   - Emphasize Friday lunchtime finish target
   - Suggest front-loading high-impact work

1. **üéØ Strategic Priorities for This Week** - START HERE (Most Important!)
   - Group by client and strategy type
   - Show impact level (üî¥ high, üü° medium, ‚ö™ low)
   - Explain WHY each priority matters THIS WEEK
   - What should be accomplished by Friday?
   - Keep to TOP 10-12 priorities (not exhaustive list)

2. **üìÖ Week Ahead - Tactical Tasks**
   - Organize by: Client tasks, Roksys internal, High priority/Due this week
   - Show: Title, due date, brief context
   - Keep to TOP 15-20 tasks (not full list)

3. **üö® Client Attention Required** - NEW! (Urgent actions this week)
   Identify clients needing immediate action based on:
   - Performance drops >15% WoW (from performance data)
   - Upcoming reporting deadlines (from tasks)
   - Budget pacing issues if mentioned
   - Critical follow-ups from meetings

   Format: One-line summary per client with specific action needed

4. **üìä Performance Context** (What happened last week to inform this week)
   - Group by trend: Strong Performers (‚Üë), Stable (‚Üí), Needs Attention (‚Üì)
   - One-sentence summary per client with key metrics
   - For declining clients: suggest "Recommended action: [specific next step]"
   - Keep concise: max 2-3 lines per client

5. **üè† PetesBrain Housekeeping** - NEW!
   Check system health and resource allocation:

   a) **System Health:**
   - LaunchAgent status (are all agents running?)
   - Any failed agents in last 7 days?
   - Authentication issues (OAuth tokens, API credentials)?
   - Disk space or performance concerns?

   b) **Client Resource Allocation:**
   - Flag clients with NO active tasks (especially high-revenue clients)
   - Flag over-allocated clients (receiving >5% more time than revenue justifies)
   - Flag under-allocated clients (receiving >5% less time than revenue justifies)
   - Suggest specific actions: create tasks, reduce complexity, or review retainer pricing

   Format: Brief status report with actionable items only. Keep concise (~5-10 lines total).

6. **üìù Context Notes** (Background info - COLLAPSED/MINIMAL)
   - Meeting notes imported (just count + client names, not details)
   - Knowledge base additions (just count + categories, not full summaries)
   - Keep to 3-5 lines total

CRITICAL FORMATTING REQUIREMENTS:
- Keep email to ~2-3 pages max (not 5-6 pages!)
- Prioritize sections 1-3 (Strategic Priorities, Tactical Tasks, Client Attention)
- Section 4-6 should be BRIEF summaries, not exhaustive details
- Use badges/highlights SPARINGLY for truly urgent items only
- White/transparent backgrounds, dark text (#333), colors only for headings/accents
- HTML email format with professional styling (#2c3e50 headings, #3498db accents)

FOCUS: This is about planning the WEEK AHEAD, not reviewing the past. Last week's data is context for decisions, not the main story.
"""

    try:
        response = anthropic_client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=4000,
            messages=[{"role": "user", "content": prompt}]
        )

        return response.content[0].text

    except Exception as e:
        log_message(f"Error analyzing with Claude: {e}")
        return None


def create_html_email(summary_content):
    """Create full HTML email with summary content"""

    today = datetime.now()
    week_start = today - timedelta(days=7)
    date_range = f"{week_start.strftime('%b %d')} - {today.strftime('%b %d, %Y')}"

    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: 0 auto; padding: 20px; }}
            h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
            h2 {{ color: #34495e; margin-top: 30px; border-left: 4px solid #3498db; padding-left: 15px; }}
            h3 {{ color: #555; margin-top: 20px; }}
            ul {{ margin-left: 20px; }}
            li {{ margin-bottom: 10px; }}
            .date {{ color: #7f8c8d; font-style: italic; font-size: 0.95em; }}
            .highlight {{ background-color: #ecf0f1; padding: 15px; border-radius: 5px; margin: 15px 0; }}
            .footer {{ margin-top: 40px; padding-top: 20px; border-top: 2px solid #ddd; color: #7f8c8d; font-size: 0.9em; }}
            .kb-badge {{ background-color: #3498db; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.85em; margin-left: 5px; }}
        </style>
    </head>
    <body>
        <h1>üìä Weekly Business Summary</h1>
        <p class="date">Week of {date_range}</p>

        {summary_content}

        <div class="footer">
            <p><strong>üìä Data Sources:</strong></p>
            <ul>
                <li>Weekly strategic priorities (AI-generated from client contexts)</li>
                <li>Client performance data (Google Ads API)</li>
                <li>Meeting notes (auto-imported from Granola)</li>
                <li>Google Tasks for upcoming work</li>
                <li>Knowledge Base documents (Google Ads, Facebook Ads, Shopify, AI Strategy, Analytics, Industry Insights)</li>
                <li>Analysis powered by Claude AI (Sonnet 4.5)</li>
            </ul>
            <p><em>This summary was automatically generated from your Pete's Brain knowledge base.</em></p>
            <p><em>üì∞ Industry news and AI updates are sent separately in the Weekly News Digest email.</em></p>
        </div>
    </body>
    </html>
    """

    return html


def create_message(to, subject, html_content):
    """Create email message."""
    message = MIMEMultipart('alternative')
    message['To'] = to
    message['From'] = 'me'
    message['Subject'] = subject

    html_part = MIMEText(html_content, 'html')
    message.attach(html_part)

    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
    return {'raw': raw_message}


def send_message(service, message):
    """Send email message."""
    try:
        sent_message = service.users().messages().send(
            userId='me',
            body=message
        ).execute()
        return sent_message
    except Exception as e:
        print(f'Error sending message: {e}')
        return None


def main():
    log_message("=" * 60)
    log_message("Weekly Business Summary Generation Started")
    log_message("=" * 60)

    # Gather new KB documents from all categories
    log_message("üìö Gathering knowledge base documents...")
    kb_documents = []
    kb_categories = ['google-ads', 'facebook-ads', 'shopify', 'ai-strategy', 'analytics', 'industry-insights', 'rok-methodologies']

    for category in kb_categories:
        category_path = KB_ROOT / category
        if category_path.exists():
            docs = get_files_from_last_week(category_path, days=7)
            kb_documents.extend(docs)
            log_message(f"  {category}: {len(docs)} new documents")

    log_message(f"üìä Total: {len(kb_documents)} KB documents")

    # Get upcoming tasks for week ahead
    log_message("üìÖ Fetching upcoming tasks for week ahead...")
    upcoming_tasks = get_upcoming_tasks()
    log_message(f"  Found {len(upcoming_tasks)} upcoming tasks")

    # Generate weekly strategy FIRST
    log_message("üéØ Generating weekly client strategy...")
    try:
        import subprocess
        result = subprocess.run(
            ['/usr/local/bin/python3', str(PROJECT_ROOT / 'shared/scripts/weekly-client-strategy-generator.py')],
            capture_output=True,
            text=True,
            timeout=300,
            env={**os.environ, 'ANTHROPIC_API_KEY': os.environ.get('ANTHROPIC_API_KEY', '')}
        )
        if result.returncode != 0:
            log_message(f"  ‚ö†Ô∏è  Strategy generator had issues: {result.stderr}")
        else:
            log_message("  ‚úì Weekly strategy generated successfully")
    except Exception as e:
        log_message(f"  ‚ö†Ô∏è  Error running strategy generator: {e}")

    # Get client performance data
    log_message("üìä Loading client performance data...")
    performance_data = get_client_performance()
    if performance_data:
        log_message(f"  Loaded performance for {len(performance_data.get('clients', []))} clients")
    else:
        log_message("  ‚ö†Ô∏è  No performance data available (may not have run yet)")

    # Get weekly strategic priorities
    log_message("üéØ Loading weekly strategic priorities...")
    strategy_data = get_weekly_client_strategy()
    if strategy_data:
        log_message(f"  Loaded {len(strategy_data.get('priorities', []))} priorities across {strategy_data.get('clients_with_priorities', 0)} clients")
    else:
        log_message("  ‚ö†Ô∏è  No strategy data available")

    # Get Granola meeting imports
    log_message("üìù Loading Granola meeting imports...")
    meeting_imports = get_granola_meeting_imports()
    if meeting_imports:
        log_message(f"  Found {meeting_imports.get('total', 0)} meeting(s) imported this week")
        if meeting_imports.get('has_unassigned'):
            log_message(f"  ‚ö†Ô∏è  Some meetings are unassigned - require manual review")
    else:
        log_message("  No meeting imports found")

    # Check LaunchAgent status
    log_message("üè† Checking LaunchAgent status...")
    launchagent_status = get_launchagent_status()
    if launchagent_status:
        if 'error' in launchagent_status:
            log_message(f"  ‚ö†Ô∏è  Could not check agents: {launchagent_status['error']}")
        elif launchagent_status.get('healthy'):
            log_message(f"  ‚úì All {launchagent_status.get('total_agents', 0)} agents healthy")
        else:
            log_message(f"  ‚ö†Ô∏è  {launchagent_status.get('failed_count', 0)} agents with issues")

    # Check resource allocation (revenue vs time)
    log_message("üí∞ Analyzing resource allocation...")
    resource_allocation = get_resource_allocation_summary()
    if resource_allocation:
        issues = []
        if resource_allocation.get('no_tasks'):
            issues.append(f"{len(resource_allocation['no_tasks'])} clients with no tasks")
        if resource_allocation.get('over_allocated'):
            issues.append(f"{len(resource_allocation['over_allocated'])} over-allocated")
        if resource_allocation.get('under_allocated'):
            issues.append(f"{len(resource_allocation['under_allocated'])} under-allocated")
        log_message(f"  ‚ö†Ô∏è  Resource imbalances detected: {', '.join(issues)}")
    else:
        log_message("  ‚úì Resource allocation is balanced")

    if len(kb_documents) == 0 and len(upcoming_tasks) == 0 and not performance_data and not strategy_data:
        log_message("‚ö†Ô∏è  No new content or upcoming tasks. Skipping email.")
        return 0

    # Analyze with Claude
    log_message("ü§ñ Analyzing content with Claude API...")
    summary_content = analyze_knowledge_base_with_claude([], kb_documents, upcoming_tasks, performance_data, strategy_data, meeting_imports, launchagent_status, resource_allocation)

    if not summary_content:
        log_message("‚ùå Failed to generate summary")
        return 1

    # Create HTML email
    log_message("üìù Creating HTML email...")
    html_email = create_html_email(summary_content)

    # Date range for subject
    today = datetime.now()
    week_start = today - timedelta(days=7)
    week_ahead_end = today + timedelta(days=7)
    subject = f"üìä Weekly Business Summary & Week Ahead - {today.strftime('%b %d')} to {week_ahead_end.strftime('%b %d')}"

    # Authenticate and send
    log_message("üîê Authenticating with Gmail...")
    creds = authenticate()

    if not creds:
        log_message("‚ùå Authentication failed")
        return 1

    try:
        service = build('gmail', 'v1', credentials=creds)

        log_message("üì§ Sending email...")
        message = create_message(
            to='petere@roksys.co.uk',
            subject=subject,
            html_content=html_email
        )

        result = send_message(service, message)

        if result:
            log_message(f"‚úÖ Email sent successfully! Message ID: {result['id']}")
            log_message("=" * 60)
            return 0
        else:
            log_message("‚ùå Failed to send email")
            return 1

    except Exception as e:
        log_message(f"‚ùå Error: {e}")
        return 1


if __name__ == '__main__':
    sys.exit(main())
