#!/usr/bin/env python3
"""
Weekly Business Summary Generator

Generates a comprehensive weekly business summary email including:
1. Strategic priorities for the week (AI-generated from client contexts)
2. Upcoming tasks and deliverables
3. Client performance data from last week
4. Meeting notes imported from Granola
5. New knowledge base documents

NOTE: Industry news and AI newsletters are sent in a SEPARATE email
      via weekly-news-digest.py

Runs every Monday at 8:30 AM
"""

import os
import sys
import base64
import anthropic
from pathlib import Path
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Gmail API imports
try:
    from google.auth.transport.requests import Request
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from googleapiclient.discovery import build
except ImportError:
    print("Error: Gmail API dependencies not installed.")
    sys.exit(1)

# Configuration
PROJECT_ROOT = Path("/Users/administrator/Documents/PetesBrain")
KB_ROOT = PROJECT_ROOT / "roksys/knowledge-base"
AI_NEWS_OLD = PROJECT_ROOT / "roksys/news/emails"  # Old location
AI_NEWS_NEW = KB_ROOT / "_inbox/emails"  # New location (will be processed into KB)

SCOPES = ['https://www.googleapis.com/auth/gmail.modify']


def log_message(message):
    """Print and log message"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")


def authenticate():
    """Authenticate with Gmail API."""
    creds = None
    # Use separate token file for weekly summary to avoid scope conflicts
    token_file = PROJECT_ROOT / 'shared/email-sync/token-weekly-summary.json'
    credentials_file = PROJECT_ROOT / 'shared/email-sync/credentials.json'

    if token_file.exists():
        creds = Credentials.from_authorized_user_file(str(token_file), SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            if not credentials_file.exists():
                print(f"Error: credentials.json not found at {credentials_file}")
                return None

            flow = InstalledAppFlow.from_client_secrets_file(
                str(credentials_file), SCOPES)
            creds = flow.run_local_server(port=0)

        with open(token_file, 'w') as token:
            token.write(creds.to_json())

    return creds


def get_files_from_last_week(directory, days=7):
    """Get files modified in the last N days"""
    if not directory.exists():
        return []

    cutoff_date = datetime.now() - timedelta(days=days)
    recent_files = []

    for file_path in directory.rglob("*.md"):
        if file_path.stat().st_mtime > cutoff_date.timestamp():
            recent_files.append(file_path)

    return sorted(recent_files, key=lambda x: x.stat().st_mtime, reverse=True)


def read_markdown_file(file_path):
    """Read markdown file and extract metadata + content"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Extract title from frontmatter or filename
        title = file_path.stem.replace('_', ' ').replace('-', ' ').title()

        if '---' in content:
            # Has frontmatter
            parts = content.split('---', 2)
            if len(parts) >= 3:
                frontmatter = parts[1]
                body = parts[2]

                # Try to extract title from frontmatter
                for line in frontmatter.split('\n'):
                    if line.startswith('title:'):
                        title = line.replace('title:', '').strip()
                        break

                return {'title': title, 'content': body, 'frontmatter': frontmatter}

        return {'title': title, 'content': content, 'frontmatter': ''}
    except Exception as e:
        log_message(f"Error reading {file_path}: {e}")
        return None


def get_client_performance():
    """Read client performance data from JSON file generated by fetch-weekly-client-performance.py"""
    try:
        import json

        performance_file = PROJECT_ROOT / "data/cache/weekly-client-performance.json"

        if not performance_file.exists():
            log_message(f"  Performance data file not found: {performance_file}")
            log_message("  Tip: Run fetch-weekly-client-performance.py to generate this data")
            return None

        with open(performance_file, 'r') as f:
            data = json.load(f)

        log_message(f"  Loaded performance data for {len(data.get('clients', []))} clients")
        return data

    except Exception as e:
        log_message(f"Warning: Could not read client performance: {e}")
        return None


def get_smythson_q4_dashboard():
    """Read Smythson Q4 dashboard data from JSON file generated by update-q4-dashboard.py"""
    try:
        import json

        dashboard_file = PROJECT_ROOT / "data/cache/smythson-q4-dashboard.json"

        if not dashboard_file.exists():
            log_message("  Smythson Q4 dashboard data not found")
            return None

        with open(dashboard_file, 'r') as f:
            data = json.load(f)

        log_message(f"  Loaded Smythson Q4 dashboard (Phase: {data['q4_period']['current_phase']})")
        return data

    except Exception as e:
        log_message(f"Warning: Could not read Smythson Q4 dashboard: {e}")
        return None


def get_upcoming_tasks():
    """Get tasks for the week ahead from Google Tasks via MCP server token"""
    try:
        from googleapiclient.discovery import build

        # Use MCP Google Tasks server token (already has tasks scope)
        mcp_tasks_dir = Path(__file__).parent.parent / 'mcp-servers/google-tasks-mcp-server'
        token_file = mcp_tasks_dir / 'token.json'

        if not token_file.exists():
            log_message(f"  MCP Tasks token not found at {token_file}")
            return []

        # Load credentials with tasks scope (use full scope, not readonly)
        tasks_scopes = ['https://www.googleapis.com/auth/tasks']
        creds = Credentials.from_authorized_user_file(str(token_file), tasks_scopes)

        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
                # Save refreshed token
                with open(token_file, 'w') as token:
                    token.write(creds.to_json())
            else:
                log_message("  Tasks credentials expired and cannot refresh")
                return []

        service = build('tasks', 'v1', credentials=creds)

        # Get all task lists
        task_lists = service.tasklists().list().execute()

        upcoming_tasks = []
        today = datetime.now()
        week_ahead = today + timedelta(days=7)

        for task_list in task_lists.get('items', []):
            list_name = task_list['title']

            # Get tasks from this list
            tasks = service.tasks().list(
                tasklist=task_list['id'],
                showCompleted=False,
                showHidden=False
            ).execute()

            for task in tasks.get('items', []):
                title = task.get('title', '')
                notes = task.get('notes', '')
                due = task.get('due')

                # Parse client from task list name if available
                client = None
                if '[' in list_name and ']' in list_name:
                    client = list_name.split('[')[1].split(']')[0]

                task_info = {
                    'title': title,
                    'notes': notes,
                    'due': due,
                    'list': list_name,
                    'client': client
                }

                # Include tasks with due dates in the next week, or important tasks without due dates
                if due:
                    try:
                        due_dt = datetime.fromisoformat(due.replace('Z', '+00:00'))
                        if today <= due_dt.replace(tzinfo=None) <= week_ahead:
                            upcoming_tasks.append(task_info)
                    except:
                        pass
                elif len(notes) > 50:  # Tasks with substantial notes are likely important
                    upcoming_tasks.append(task_info)

        return upcoming_tasks

    except Exception as e:
        log_message(f"Warning: Could not fetch upcoming tasks: {e}")
        return []


def get_weekly_client_strategy():
    """Get AI-generated weekly strategic priorities for all clients"""
    strategy_file = PROJECT_ROOT / 'shared' / 'data' / 'weekly-client-strategy.json'

    if not strategy_file.exists():
        return None

    try:
        import json
        with open(strategy_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        log_message(f"Warning: Could not read client strategy: {e}")
        return None

def get_granola_meeting_imports():
    """Get Granola meeting imports from the last 7 days"""
    try:
        import json
        history_file = PROJECT_ROOT / 'tools/granola-importer/.import_history.json'

        if not history_file.exists():
            return None

        with open(history_file, 'r') as f:
            history = json.load(f)

        # Get imports from last 7 days
        cutoff = datetime.now() - timedelta(days=7)
        recent_imports = []

        for doc_id, import_data in history.get('imported', {}).items():
            imported_at = import_data.get('imported_at', '')
            try:
                import_time = datetime.fromisoformat(imported_at)
                if import_time >= cutoff:
                    # Extract filename and client
                    file_path = import_data.get('file_path', '')
                    filename = Path(file_path).name if file_path else 'Unknown'
                    client = import_data.get('client', '_unassigned')

                    recent_imports.append({
                        'filename': filename,
                        'client': client,
                        'imported_at': imported_at,
                        'time_display': import_time.strftime('%b %d, %H:%M')
                    })
            except ValueError:
                continue

        # Sort by import time (newest first)
        recent_imports.sort(key=lambda x: x['imported_at'], reverse=True)

        # Group by client
        grouped = {}
        for imp in recent_imports:
            client = imp['client']
            if client == '_unassigned':
                client = '‚ö†Ô∏è Unassigned'
            else:
                client = client.replace('-', ' ').title()

            if client not in grouped:
                grouped[client] = []
            grouped[client].append(imp)

        return {
            'total': len(recent_imports),
            'grouped': grouped,
            'has_unassigned': any(imp['client'] == '_unassigned' for imp in recent_imports)
        }

    except Exception as e:
        log_message(f"Warning: Could not read Granola imports: {e}")
        return None

def analyze_knowledge_base_with_claude(ai_emails, kb_documents, upcoming_tasks, performance_data=None, strategy_data=None, meeting_imports=None, smythson_q4_data=None):
    """Use Claude API to analyze and summarize the knowledge base"""

    api_key = os.environ.get('ANTHROPIC_API_KEY')
    if not api_key:
        log_message("ERROR: ANTHROPIC_API_KEY not set")
        return None

    anthropic_client = anthropic.Anthropic(api_key=api_key)

    # Prepare content for Claude
    email_summaries = []
    for email in ai_emails[:20]:  # Limit to 20 most recent emails
        doc = read_markdown_file(email)
        if doc:
            email_summaries.append(f"### {doc['title']}\n{doc['content'][:1000]}")  # First 1000 chars

    kb_summaries = []
    for kb_doc in kb_documents[:10]:  # Limit to 10 most recent KB docs
        doc = read_markdown_file(kb_doc)
        if doc:
            kb_summaries.append(f"### {doc['title']}\n{doc['content'][:1000]}")

    # Prepare upcoming tasks summaries
    task_summaries = []
    for task in upcoming_tasks[:20]:  # Limit to 20 tasks
        client_prefix = f"[{task['client']}] " if task['client'] else ""
        due_str = f" (Due: {task['due'][:10]})" if task['due'] else ""
        task_summaries.append(f"{client_prefix}{task['title']}{due_str}")

    # Prepare weekly strategic priorities summaries
    strategy_summaries = []
    strategy_by_type = {}
    weekend_context = ""
    if strategy_data and strategy_data.get('priorities'):
        for priority in strategy_data['priorities']:
            client = priority.get('client', 'Unknown')
            type_key = priority.get('type', 'other')
            impact = priority.get('impact', 'medium')
            priority_text = priority.get('priority', '')
            why = priority.get('why', '')

            # Group by type for summary
            if type_key not in strategy_by_type:
                strategy_by_type[type_key] = []
            strategy_by_type[type_key].append(f"[{client}] {priority_text}")

            # Individual priority summary
            impact_emoji = "üî¥" if impact == "high" else ("üü°" if impact == "medium" else "‚ö™")
            strategy_summaries.append(f"{impact_emoji} [{client}] {priority_text} - {why}")

    # Extract weekend plans if available
    if strategy_data and strategy_data.get('weekend_plans'):
        plans = strategy_data['weekend_plans']
        weekend_context = f"""
**‚ö†Ô∏è WEEKEND PLANS DETECTED**: {plans.get('summary', 'Weekend plans')}
**Recommendation**: Aim to finish by lunchtime Friday ({plans.get('friday_date', 'Friday')}) to allow for travel/preparation.
"""

    # Prepare client performance summaries
    performance_summaries = []
    period_str = "data pending"
    if performance_data and performance_data.get('clients'):
        period = performance_data.get('period', {})
        current_week = period.get('current_week', {})
        period_str = f"{current_week.get('start', '')} to {current_week.get('end', '')}"

        for client_data in performance_data['clients'][:12]:  # All 12 clients
            name = client_data['name']
            curr = client_data['current_week']
            changes = client_data['changes']
            summary = client_data['summary']

            # Format performance line
            perf_line = f"{name}: ¬£{int(curr['revenue']):,} revenue, {int(curr['roas'])}% ROAS"
            if changes['trend'] == 'up':
                perf_line += f" (‚Üë {abs(int(changes['revenue_pct']))}% WoW)"
            elif changes['trend'] == 'down':
                perf_line += f" (‚Üì {abs(int(changes['revenue_pct']))}% WoW)"
            else:
                perf_line += f" (‚Üí stable)"

            # Add outliers if present
            if client_data.get('outliers'):
                outlier_dates = [o['date'] for o in client_data['outliers'][:2]]
                perf_line += f" | Notable: {', '.join(outlier_dates)}"

            performance_summaries.append(perf_line)

    # Prepare meeting imports summaries
    meeting_summaries = []
    if meeting_imports and meeting_imports.get('total', 0) > 0:
        for client, meetings in sorted(meeting_imports['grouped'].items()):
            meeting_summaries.append(f"{client}: {len(meetings)} meeting(s)")
            for meeting in meetings[:3]:  # Show up to 3 per client
                meeting_summaries.append(f"  ‚Ä¢ {meeting['filename']} ({meeting['time_display']})")

    prompt = f"""You are analyzing the Pete's Brain knowledge base for a weekly business summary email.
{weekend_context}
**WEEKLY STRATEGIC PRIORITIES** ({len(strategy_summaries)} priorities across {strategy_data.get('clients_with_priorities', 0) if strategy_data else 0} clients):
{chr(10).join(strategy_summaries[:30]) if strategy_summaries else 'Strategic priorities pending - run weekly-client-strategy-generator.py'}

**BY STRATEGY TYPE**:
{chr(10).join([f"  {type_name}: {len(items)}" for type_name, items in strategy_by_type.items()]) if strategy_by_type else 'N/A'}

**CLIENT PERFORMANCE - LAST WEEK** ({len(performance_summaries)} clients, {period_str if performance_summaries else 'data pending'}):
{chr(10).join(performance_summaries) if performance_summaries else 'Performance data pending - run fetch-weekly-client-performance.py'}

**NEW KNOWLEDGE BASE DOCUMENTS THIS WEEK** ({len(kb_documents)} total):
{chr(10).join(kb_summaries) if kb_summaries else 'No documents this week'}

**UPCOMING TASKS - WEEK AHEAD** ({len(upcoming_tasks)} tasks):
{chr(10).join(task_summaries) if task_summaries else 'No upcoming tasks'}

**MEETING NOTES IMPORTED THIS WEEK** ({meeting_imports.get('total', 0) if meeting_imports else 0} meetings from Granola):
{chr(10).join(meeting_summaries) if meeting_summaries else 'No meetings imported this week'}

**SMYTHSON Q4 STRATEGY CONTROL DASHBOARD** (Updated: {smythson_q4_data.get('last_updated', 'N/A') if smythson_q4_data else 'Not available'}):
{f'''Q4 Period: {smythson_q4_data['q4_period']['start']} to {smythson_q4_data['q4_period']['end']} (Day {smythson_q4_data['q4_period']['days_elapsed']}/{smythson_q4_data['q4_period']['days_elapsed'] + smythson_q4_data['q4_period']['days_remaining']})
Current Phase: {smythson_q4_data['q4_period']['current_phase']}

Overall Performance:
  Revenue: ¬£{smythson_q4_data['overall']['revenue']:,.2f} / ¬£{smythson_q4_data['overall']['revenue_target']:,.0f} ({smythson_q4_data['overall']['revenue_progress_pct']}% of target)
  Spend: ¬£{smythson_q4_data['overall']['spend']:,.2f} / ¬£{smythson_q4_data['overall']['budget']:,.0f} ({smythson_q4_data['overall']['budget_pacing_pct']}% pacing)
  ROAS: {smythson_q4_data['overall']['roas']:.2f} (Target: {smythson_q4_data['overall']['roas_target']:.2f})

Regional Performance:
  UK:  ROAS {smythson_q4_data['regional']['UK']['roas']:.2f} | Revenue ¬£{smythson_q4_data['regional']['UK']['revenue']:,.2f} | Spend ¬£{smythson_q4_data['regional']['UK']['spend']:,.2f}
  USA: ROAS {smythson_q4_data['regional']['USA']['roas']:.2f} | Revenue ¬£{smythson_q4_data['regional']['USA']['revenue']:,.2f} | Spend ¬£{smythson_q4_data['regional']['USA']['spend']:,.2f}
  EUR: ROAS {smythson_q4_data['regional']['EUR']['roas']:.2f} | Revenue ¬£{smythson_q4_data['regional']['EUR']['revenue']:,.2f} | Spend ¬£{smythson_q4_data['regional']['EUR']['spend']:,.2f}
  ROW: ROAS {smythson_q4_data['regional']['ROW']['roas']:.2f} | Revenue ¬£{smythson_q4_data['regional']['ROW']['revenue']:,.2f} | Spend ¬£{smythson_q4_data['regional']['ROW']['spend']:,.2f}

Dashboard: https://docs.google.com/spreadsheets/d/10vRzZJuUQMX0l86plKcuZfdoiidoexI1LPYnhr6gJlU/edit''' if smythson_q4_data else 'Smythson Q4 dashboard data not available'}

Please create a comprehensive weekly summary with the following sections:

0. **‚ö†Ô∏è WEEKEND PLANS NOTICE** (if weekend plans detected)
   Display prominently at the TOP of the email if weekend plans are detected:
   - Show the weekend plan summary (e.g., "Grasmere", "Lake District holiday")
   - Emphasize the Friday lunchtime finish recommendation
   - Use eye-catching formatting (warning box, emoji, bold text)
   - Suggest prioritizing high-impact work early in the week

1. **üéØ Strategic Priorities for This Week** - CRITICAL SECTION - ALWAYS INCLUDE FIRST!
   Organize by client and strategic focus areas:
   - Group by strategy type (reporting, optimization, planning, communication, review, experiment)
   - Show impact level (high/medium/low) for each priority
   - Explain WHY each priority matters this week
   - Make this actionable - what should be accomplished by Friday (or earlier if weekend plans exist)?

   Think strategic, not tactical. These are weekly goals, not daily tasks.

2. **üìÖ Week Ahead - Tactical Tasks** - IMPORTANT SECTION
   Organize upcoming tasks by:
   - Tasks by Client (group by client name if available)
   - Roksys Internal Tasks
   - High Priority / Due This Week (tasks with due dates)

   For each task, show:
   - Task title
   - Due date (if available)
   - Brief context from notes if relevant

2b. **üìù Meeting Notes Imported This Week** - NEW SECTION!
   Show meeting notes that were automatically imported from Granola:
   - Group by client
   - Show meeting count per client
   - List meeting note filenames (first 3-5 per client)
   - Add warning if any meetings are unassigned to clients
   - Brief summary of meeting topics if notable

3. **üìä Smythson Q4 Strategy Dashboard** - FEATURED CLIENT SECTION
   If Smythson Q4 data is available, create a prominent section showing:
   - Overall Q4 progress (revenue vs target, spend vs budget, ROAS)
   - Current phase of the Q4 strategy
   - Regional performance breakdown (UK, USA, EUR, ROW with ROAS)
   - Days elapsed / days remaining in Q4
   - Link to full dashboard
   - Brief analysis: Is Smythson on track? Any regions exceeding/missing targets?

   Format as a prominent card/box with clear metrics and traffic light status if appropriate.

4. **üìä Client Performance - Last Week** - CRITICAL INSIGHTS SECTION
   Summarize client performance data in an easy-to-scan format:
   - Group clients by performance trend (Up/Stable/Down)
   - For each client, show one-sentence summary with key metrics
   - Highlight notable outliers or performance spikes
   - Call out any clients needing immediate attention

   Format like this:
   **Strong Performers (‚Üë):**
   - [Client]: Brief summary from data

   **Stable Performers (‚Üí):**
   - [Client]: Brief summary

   **Needs Attention (‚Üì):**
   - [Client]: Brief summary + any outlier notes

5. **Knowledge Base Additions** - Summarize new documents added to the knowledge base this week, grouped by category (Google Ads, AI Strategy, Analytics, etc.)

5. **Key Insights for ROK** - 3-5 actionable insights or strategic takeaways relevant to digital marketing and PPC management

6. **This Week in Numbers** - Key statistics, dates, or figures mentioned

IMPORTANT:
1. "Strategic Priorities for This Week" must be FIRST - this is the weekly planning guide
2. "Week Ahead - Tactical Tasks" second - these are the specific to-dos
3. "Client Performance" third - context for decision-making
These three sections are the MOST ACTIONABLE parts of the email.

Format the response as HTML suitable for email, with proper headings, bullet points, and styling. Use a professional, clean design with colors #2c3e50 for main headings and #3498db for accents. Use badges/highlights for high-impact priorities and urgent tasks.

CRITICAL FORMATTING RULE: Do NOT add any background colors or text colors to section content. All sections must have a white/transparent background with standard dark text (#333 or similar). Only use colors for badges, headings borders, and accent elements - never for section backgrounds or body text.

NOTE: This is a BUSINESS SUMMARY email focused on strategic priorities, tasks, performance, and meeting notes. Industry news and AI newsletters are covered in a SEPARATE weekly news digest email.
"""

    try:
        response = anthropic_client.messages.create(
            model="claude-sonnet-4-5-20250929",
            max_tokens=4000,
            messages=[{"role": "user", "content": prompt}]
        )

        return response.content[0].text

    except Exception as e:
        log_message(f"Error analyzing with Claude: {e}")
        return None


def create_html_email(summary_content):
    """Create full HTML email with summary content"""

    today = datetime.now()
    week_start = today - timedelta(days=7)
    date_range = f"{week_start.strftime('%b %d')} - {today.strftime('%b %d, %Y')}"

    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: 0 auto; padding: 20px; }}
            h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
            h2 {{ color: #34495e; margin-top: 30px; border-left: 4px solid #3498db; padding-left: 15px; }}
            h3 {{ color: #555; margin-top: 20px; }}
            ul {{ margin-left: 20px; }}
            li {{ margin-bottom: 10px; }}
            .date {{ color: #7f8c8d; font-style: italic; font-size: 0.95em; }}
            .highlight {{ background-color: #ecf0f1; padding: 15px; border-radius: 5px; margin: 15px 0; }}
            .footer {{ margin-top: 40px; padding-top: 20px; border-top: 2px solid #ddd; color: #7f8c8d; font-size: 0.9em; }}
            .kb-badge {{ background-color: #3498db; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.85em; margin-left: 5px; }}
        </style>
    </head>
    <body>
        <h1>üìä Weekly Business Summary</h1>
        <p class="date">Week of {date_range}</p>

        {summary_content}

        <div class="footer">
            <p><strong>üìä Data Sources:</strong></p>
            <ul>
                <li>Weekly strategic priorities (AI-generated from client contexts)</li>
                <li>Client performance data (Google Ads API)</li>
                <li>Meeting notes (auto-imported from Granola)</li>
                <li>Google Tasks for upcoming work</li>
                <li>Knowledge Base documents (Google Ads, AI Strategy, Analytics, Industry Insights)</li>
                <li>Analysis powered by Claude AI (Sonnet 4.5)</li>
            </ul>
            <p><em>This summary was automatically generated from your Pete's Brain knowledge base.</em></p>
            <p><em>üì∞ Industry news and AI updates are sent separately in the Weekly News Digest email.</em></p>
        </div>
    </body>
    </html>
    """

    return html


def create_message(to, subject, html_content):
    """Create email message."""
    message = MIMEMultipart('alternative')
    message['To'] = to
    message['From'] = 'me'
    message['Subject'] = subject

    html_part = MIMEText(html_content, 'html')
    message.attach(html_part)

    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode('utf-8')
    return {'raw': raw_message}


def send_message(service, message):
    """Send email message."""
    try:
        sent_message = service.users().messages().send(
            userId='me',
            body=message
        ).execute()
        return sent_message
    except Exception as e:
        print(f'Error sending message: {e}')
        return None


def main():
    log_message("=" * 60)
    log_message("Weekly Business Summary Generation Started")
    log_message("=" * 60)

    # Gather new KB documents from all categories
    log_message("üìö Gathering knowledge base documents...")
    kb_documents = []
    kb_categories = ['google-ads', 'ai-strategy', 'analytics', 'industry-insights', 'rok-methodologies']

    for category in kb_categories:
        category_path = KB_ROOT / category
        if category_path.exists():
            docs = get_files_from_last_week(category_path, days=7)
            kb_documents.extend(docs)
            log_message(f"  {category}: {len(docs)} new documents")

    log_message(f"üìä Total: {len(kb_documents)} KB documents")

    # Get upcoming tasks for week ahead
    log_message("üìÖ Fetching upcoming tasks for week ahead...")
    upcoming_tasks = get_upcoming_tasks()
    log_message(f"  Found {len(upcoming_tasks)} upcoming tasks")

    # Generate weekly strategy FIRST
    log_message("üéØ Generating weekly client strategy...")
    try:
        import subprocess
        result = subprocess.run(
            ['/usr/local/bin/python3', str(PROJECT_ROOT / 'shared/scripts/weekly-client-strategy-generator.py')],
            capture_output=True,
            text=True,
            timeout=300,
            env={**os.environ, 'ANTHROPIC_API_KEY': os.environ.get('ANTHROPIC_API_KEY', '')}
        )
        if result.returncode != 0:
            log_message(f"  ‚ö†Ô∏è  Strategy generator had issues: {result.stderr}")
        else:
            log_message("  ‚úì Weekly strategy generated successfully")
    except Exception as e:
        log_message(f"  ‚ö†Ô∏è  Error running strategy generator: {e}")

    # Get client performance data
    log_message("üìä Loading client performance data...")
    performance_data = get_client_performance()
    if performance_data:
        log_message(f"  Loaded performance for {len(performance_data.get('clients', []))} clients")
    else:
        log_message("  ‚ö†Ô∏è  No performance data available (may not have run yet)")

    # Get weekly strategic priorities
    log_message("üéØ Loading weekly strategic priorities...")
    strategy_data = get_weekly_client_strategy()
    if strategy_data:
        log_message(f"  Loaded {len(strategy_data.get('priorities', []))} priorities across {strategy_data.get('clients_with_priorities', 0)} clients")
    else:
        log_message("  ‚ö†Ô∏è  No strategy data available")

    # Get Granola meeting imports
    log_message("üìù Loading Granola meeting imports...")
    meeting_imports = get_granola_meeting_imports()
    if meeting_imports:
        log_message(f"  Found {meeting_imports.get('total', 0)} meeting(s) imported this week")
        if meeting_imports.get('has_unassigned'):
            log_message(f"  ‚ö†Ô∏è  Some meetings are unassigned - require manual review")
    else:
        log_message("  No meeting imports found")

    # Get Smythson Q4 dashboard data
    log_message("üìä Loading Smythson Q4 dashboard data...")
    smythson_q4_data = get_smythson_q4_dashboard()

    if len(kb_documents) == 0 and len(upcoming_tasks) == 0 and not performance_data and not strategy_data:
        log_message("‚ö†Ô∏è  No new content or upcoming tasks. Skipping email.")
        return 0

    # Analyze with Claude
    log_message("ü§ñ Analyzing content with Claude API...")
    summary_content = analyze_knowledge_base_with_claude([], kb_documents, upcoming_tasks, performance_data, strategy_data, meeting_imports, smythson_q4_data)

    if not summary_content:
        log_message("‚ùå Failed to generate summary")
        return 1

    # Create HTML email
    log_message("üìù Creating HTML email...")
    html_email = create_html_email(summary_content)

    # Date range for subject
    today = datetime.now()
    week_start = today - timedelta(days=7)
    week_ahead_end = today + timedelta(days=7)
    subject = f"üìä Weekly Business Summary & Week Ahead - {today.strftime('%b %d')} to {week_ahead_end.strftime('%b %d')}"

    # Authenticate and send
    log_message("üîê Authenticating with Gmail...")
    creds = authenticate()

    if not creds:
        log_message("‚ùå Authentication failed")
        return 1

    try:
        service = build('gmail', 'v1', credentials=creds)

        log_message("üì§ Sending email...")
        message = create_message(
            to='petere@roksys.co.uk',
            subject=subject,
            html_content=html_email
        )

        result = send_message(service, message)

        if result:
            log_message(f"‚úÖ Email sent successfully! Message ID: {result['id']}")
            log_message("=" * 60)
            return 0
        else:
            log_message("‚ùå Failed to send email")
            return 1

    except Exception as e:
        log_message(f"‚ùå Error: {e}")
        return 1


if __name__ == '__main__':
    sys.exit(main())
